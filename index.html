<!DOCTYPE html>
<html lang="en">
<!-- 
    Falling Sheep
    All art and ideas by Nico Wilson
    Implementation by Jake Wilson & Gemini
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Falling Sheep</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
            background-color: #f0f0f0;
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrolling on mobile */
        }
        main {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
            max-width: 1400px; /* Allow scaling up on larger screens */
        }
        #gameContainer {
            position: relative;
            width: 100%;
            flex: 1; /* Grow to fill available vertical space */
            min-height: 0; /* Fix for flexbox overflow issue */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #gameCanvas {
            border: 2px solid #333;
            background-color: #fff;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            border-radius: 8px;
            display: block;
            /* CSS to scale properly while maintaining aspect ratio */
            aspect-ratio: 800 / 618;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        #launchScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 800 / 618;
            object-fit: cover;
            border-radius: 8px; /* Match canvas */
            z-index: 10;
            pointer-events: none; /* Allow clicks to pass through to the button */
        }
        #credits {
            margin-top: 1rem;
            color: #4A5568;
            text-align: center;
            font-size: 14px;
            flex-shrink: 0; /* Prevent credits from shrinking */
        }
        #startButton {
            position: absolute;
            top: 76.5%; /* Adjusted button position */
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 1rem 2rem;
            font-size: 2rem;
            font-weight: bold;
            color: white;
            background: linear-gradient(145deg, #3B82F6, #2563EB);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            transition: all 0.2s ease-in-out;
            z-index: 20;
        }
        #startButton:hover {
            transform: translate(-50%, -52%);
            box-shadow: 0 6px 10px rgba(0,0,0,0.3);
        }
    </style>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap">
</head>
<body>
    <main>
        <div id="gameContainer">
            <canvas id="gameCanvas"></canvas>
            <img id="launchScreen" src="https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/launchScreen.png" alt="Raining Sheep Game">
            <button id="startButton">Start Game</button>
        </div>
        <div id="credits">
            All art and ideas by Nico Wilson<br>
            Implementation by Jake Wilson &amp; Gemini
        </div>
    </main>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const launchScreen = document.getElementById('launchScreen');
        const credits = document.getElementById('credits');

        // Base game dimensions for scaling
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 618;

        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;

        // Game State
        let isGameOver = false;
        let isPaused = false;
        let playerWon = false;
        let missedCount = 0;
        let sheepInterval;
        let gameStarted = false;
        let goldenSheepChance = 0.1;
        let goldenHits = 0;
        let gameOverMessage = '';
        let loseReason = '';
        let owMessage = { text: '', alpha: 0, x: 0, y: 0 };
        let mooMessage = { text: '', alpha: 0, x: 0, y: 0 };
        let booMessage = { text: '', alpha: 0, x: 0, y: 0 };
        let currentLevel = 1;
        let levelSpeedMultiplier = 1;
        let levelCatchGoal = 10;
        let totalSheepSaved = 0;
        let totalSheepLost = 0;
        let totalGoldenHits = 0;
        
        // --- DECK MANAGEMENT ---
        let sheepQueue = []; // The deck for the current level
        let discardPile = []; // Discarded sheep for the current level
        
        // Input state
        let isPointerActive = false;
        let pointerGameX = null;


        // Player (Sprite) properties
        const player = {
            x: GAME_WIDTH / 2 - 35,
            y: GAME_HEIGHT - 90,
            width: 70,
            height: 80,
            speed: 7,
            dx: 0
        };
        
        const originalPlayerState = {
            height: player.height,
            speed: player.speed,
            y: player.y
        };

        // Cow properties
        const cow = {
            x: 100,
            y: GAME_HEIGHT - 110,
            width: 100,
            height: 100,
            speed: 2,
            dx: 2,
            image: null
        };
        
        // Scarecrow properties
        const scarecrow = {
            x: 50,
            y: GAME_HEIGHT - 110,
            width: 80,
            height: 100,
            speed: 1.5,
            dx: 1.5,
            image: null
        };

        // Sheep properties
        let sheep = [];
        const sheepWidth = 60;
        const sheepHeight = 60;
        const scaredPhrases = ["Eep!", "Scary!", "Get me out of here!", "AAHHH!", "Oh no!"];

        // Score stack properties
        let caughtSheep = [];
        let scoreSheepWidth = 50;
        let scoreSheepHeight = 50;
        
        // Graves properties
        let missedGraves = [];
        
        // --- Image Loading ---
        const allImages = {};
        const sheepImages = [];
        const normalSheepImages = [];
        const graveImages = [];
        const goldenImages = [];
        let assetsToLoad = 0;
        let assetsLoaded = 0;

        const imageUrls = {
            launchScreen: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/launchScreen.png',
            background: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/background.png',
            sheep1: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep01.png',
            sheep2: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep02.png',
            sheep3: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep03.png',
            sheep4: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep04.png',
            sheep5: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep05.png',
            sheep6: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep06.png',
            sheep7: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep07.png',
            sheep8: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep08.png',
            sheep9: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep09.png',
            sheep10: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep10.png',
            sheep11: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep11.png',
            sheep12: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep12.png',
            sheep13: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep13.png',
            sheep14: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep14.png',
            sheep15: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep15.png',
            sheep16: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep16.png',
            sheep17: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep17.png',
            sheep18: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep18.png',
            sheep19: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep19.png',
            sheep20: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep20.png',
            sheep21: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep21.png',
            sheep22: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep22.png',
            sheep23: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep23.png',
            sheep24: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep24.png',
            sheep25: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/sheep25.png',
            goldenSheep: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/goldenSheep.png',
            goldenBull: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/goldenBull.png',
            goldenTractor: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/goldenTractor.png',
            goldenCow: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/goldenCow.png',
            goldenCowLeft: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/goldenCowLeft.png',
            goldenCowRight: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/goldenCowRight.png',
            scarecrow: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/scarecrow.png',
            scarecrowLeft: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/goldenScarecrowLeft.png',
            scarecrowRight: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/goldenScarecrowRight.png',
            grave1: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/grave1.png',
            grave2: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/grave2.png',
            grave3: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/grave3.png',
            playerDefault: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/farmer.png',
            playerLeft: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/farmerLeft.png',
            playerRight: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/farmerRight.png',
            youWin: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/youWin.png',
            youLose: 'https://cdn.jsdelivr.net/gh/misterwilson37/rainingSheep/youLose.png'
        };

        assetsToLoad = Object.keys(imageUrls).length;

        function onAssetLoad() {
            assetsLoaded++;
            if (assetsLoaded === assetsToLoad) {
                // More robust way to populate image arrays
                Object.keys(allImages).forEach(key => {
                    if (key.startsWith('sheep')) {
                        sheepImages.push(allImages[key]);
                    }
                });
                
                normalSheepImages.push(allImages.sheep1, allImages.sheep2, allImages.sheep6, allImages.sheep7, allImages.sheep10);
                graveImages.push(allImages.grave1, allImages.grave2, allImages.grave3);
                goldenImages.push(allImages.goldenSheep, allImages.goldenBull, allImages.goldenTractor);
                cow.image = allImages.goldenCow;
                scarecrow.image = allImages.scarecrow;
                gameLoop();
            }
        }

        for (const [name, url] of Object.entries(imageUrls)) {
            const img = new Image();
            img.onload = onAssetLoad;
            img.onerror = () => {
                console.error(`Failed to load image: ${name} at ${url}`);
                onAssetLoad();
            };
            img.crossOrigin = "Anonymous";
            img.src = url;
            allImages[name] = img;
        }

        // --- Drawing Functions ---

        function drawPlayer() {
            let currentImage = allImages.playerDefault;
            if (player.dx < 0) {
                currentImage = allImages.playerLeft;
            } else if (player.dx > 0) {
                currentImage = allImages.playerRight;
            }
            
            if (currentImage && currentImage.complete && currentImage.naturalHeight !== 0) {
                ctx.drawImage(currentImage, player.x, player.y, player.width, player.height);
            } else {
                ctx.fillStyle = '#3B82F6';
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }
        }
        
        function drawCow() {
            let imageToDraw = allImages.goldenCow;
            if (cow.dx < 0 && allImages.goldenCowLeft) {
                imageToDraw = allImages.goldenCowLeft;
            } else if (cow.dx > 0 && allImages.goldenCowRight) {
                imageToDraw = allImages.goldenCowRight;
            }
            if (imageToDraw && imageToDraw.complete && imageToDraw.naturalHeight !== 0) {
                ctx.drawImage(imageToDraw, cow.x, cow.y, cow.width, cow.height);
            }
        }

        function drawScarecrow() {
            let imageToDraw = allImages.scarecrow;
             if (scarecrow.dx < 0 && allImages.scarecrowLeft) {
                imageToDraw = allImages.scarecrowLeft;
            } else if (scarecrow.dx > 0 && allImages.scarecrowRight) {
                imageToDraw = allImages.scarecrowRight;
            }
            if (imageToDraw && imageToDraw.complete && imageToDraw.naturalHeight !== 0) {
                ctx.drawImage(imageToDraw, scarecrow.x, scarecrow.y, scarecrow.width, scarecrow.height);
            }
        }

        function drawGraves() {
            missedGraves.forEach(grave => {
                if (grave.image && grave.image.complete && grave.image.naturalHeight !== 0) {
                    ctx.drawImage(grave.image, grave.x, grave.y, grave.width, grave.height);
                }
            });
        }

        function drawFallingSheep() {
            sheep.forEach(s => {
                if (s.image && s.image.complete && s.image.naturalHeight !== 0) {
                    ctx.save();
                    ctx.translate(s.x + s.width / 2, s.y + s.height / 2);
                    ctx.rotate(s.rotation);
                    ctx.drawImage(s.image, -s.width / 2, -s.height / 2, s.width, s.height);
                    ctx.restore();
                }
            });
        }
        
        function drawFleeingText() {
            sheep.forEach(s => {
                if (s.scaredText && s.scaredText.alpha > 0) {
                    ctx.save();
                    ctx.globalAlpha = s.scaredText.alpha;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.font = '16px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText(s.scaredText.text, s.x + s.width / 2, s.y - 10);
                    ctx.restore();
                }
            });
        }
        
        function drawScoreStack() {
            const stackXPosition = GAME_WIDTH - scoreSheepWidth - 10;
            caughtSheep.forEach((s, index) => {
                const yPos = GAME_HEIGHT - (index + 1) * scoreSheepHeight;
                 if (s.image && s.image.complete && s.image.naturalHeight !== 0) {
                    ctx.save();
                    ctx.translate(stackXPosition + scoreSheepWidth / 2, yPos + scoreSheepHeight / 2);
                    ctx.rotate(s.rotation);
                    ctx.drawImage(s.image, -scoreSheepWidth / 2, -scoreSheepHeight / 2, scoreSheepWidth, scoreSheepHeight);
                    ctx.restore();
                 }
            });
        }
        
        function drawUI() {
            ctx.fillStyle = 'black';
            ctx.font = 'bold 24px Inter';
            ctx.textAlign = 'left';
            ctx.fillText(`Level: ${currentLevel}`, 10, 30);
            const goalText = `Goal: ${caughtSheep.length} / ${levelCatchGoal}`;
            ctx.fillText(goalText, 10, 60);
        }

        function drawPauseScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 72px Inter';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', GAME_WIDTH / 2, GAME_HEIGHT / 2);
        }

        function drawOwMessage() {
            if (owMessage.alpha > 0) {
                ctx.save();
                ctx.globalAlpha = owMessage.alpha;
                ctx.fillStyle = 'red';
                ctx.font = 'bold 36px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(owMessage.text, owMessage.x, owMessage.y);
                ctx.restore();
            }
        }

        function drawMooMessage() {
            if (mooMessage.alpha > 0) {
                ctx.save();
                ctx.globalAlpha = mooMessage.alpha;
                ctx.fillStyle = '#FFD700';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.font = 'bold 40px Inter';
                ctx.textAlign = 'center';
                ctx.strokeText(mooMessage.text, mooMessage.x, mooMessage.y);
                ctx.fillText(mooMessage.text, mooMessage.x, mooMessage.y);
                ctx.restore();
            }
        }

        function drawBooMessage() {
            if (booMessage.alpha > 0) {
                ctx.save();
                ctx.globalAlpha = booMessage.alpha;
                ctx.fillStyle = '#A0522D';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.font = 'bold 40px Inter';
                ctx.textAlign = 'center';
                ctx.strokeText(booMessage.text, booMessage.x, booMessage.y);
                ctx.fillText(booMessage.text, booMessage.x, booMessage.y);
                ctx.restore();
            }
        }

        function drawGameOver() {
            ctx.textAlign = 'center';

            if (playerWon) {
                 if (gameOverMessage.includes('Level')) {
                     ctx.fillStyle = 'white';
                     ctx.font = 'bold 72px Inter';
                     ctx.fillText(gameOverMessage, GAME_WIDTH / 2, GAME_HEIGHT / 2 - 50);
                 } else {
                    const image = allImages.youWin;
                    if (image && image.complete && image.naturalHeight !== 0) {
                        const imgWidth = 400; const imgHeight = 200;
                        ctx.drawImage(image, GAME_WIDTH / 2 - imgWidth / 2, GAME_HEIGHT / 2 - imgHeight / 2 - 50, imgWidth, imgHeight);
                    }
                 }
            } else { // Player Lost
                const image = allImages.youLose;
                if (image && image.complete && image.naturalHeight !== 0) {
                    const imgWidth = 400; const imgHeight = 200;
                    ctx.drawImage(image, GAME_WIDTH / 2 - imgWidth / 2, GAME_HEIGHT / 2 - imgHeight / 2 - 90, imgWidth, imgHeight);
                }
            }
            
            ctx.font = 'bold 24px Inter';
            const finalSavedCount = totalSheepSaved;
            
            if (playerWon) {
                const statsY = GAME_HEIGHT / 2 + 50;
                ctx.fillStyle = 'white';
                ctx.fillText(`Total Sheep Saved: ${finalSavedCount}`, GAME_WIDTH / 2, statsY);
                ctx.fillText(`Total Sheep Lost: ${totalSheepLost}`, GAME_WIDTH / 2, statsY + 30);
                ctx.fillText(`Total Golden Hits: ${totalGoldenHits}`, GAME_WIDTH / 2, statsY + 60);
            } else {
                const statsY = GAME_HEIGHT / 2 + 10; // Moved stats up further for better spacing
                ctx.fillStyle = 'white';
                ctx.fillText(loseReason, GAME_WIDTH / 2, statsY);
                ctx.fillText(`Total Sheep Saved: ${finalSavedCount}`, GAME_WIDTH / 2, statsY + 30);
                ctx.fillText(`Total Sheep Lost: ${totalSheepLost}`, GAME_WIDTH / 2, statsY + 60);
                ctx.fillText(`Total Golden Hits: ${totalGoldenHits}`, GAME_WIDTH / 2, statsY + 90);
            }
            
            if (playerWon && currentLevel < 8) {
                startButton.textContent = `Start Level ${currentLevel + 1}`;
            } else if (playerWon) {
                 startButton.textContent = 'You Win! Play Again?';
            } else {
                startButton.textContent = 'Try Again?';
            }
            startButton.style.display = 'block';
        }

        // --- Game Logic ---

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function clear() {
            if (allImages.background && allImages.background.complete && allImages.background.naturalHeight !== 0) {
                ctx.drawImage(allImages.background, 0, 0, GAME_WIDTH, GAME_HEIGHT);
            } else {
                const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#E0F8FF');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            }
        }

        function createSheep() {
            const x = Math.random() * (GAME_WIDTH - scoreSheepWidth - 10 - sheepWidth);
            const y = -sheepHeight;
            let speed;
            let newSheep;

            if (Math.random() < goldenSheepChance) {
                const randomGoldenImage = goldenImages[Math.floor(Math.random() * goldenImages.length)];
                speed = (Math.random() * 2 + 2) * levelSpeedMultiplier;
                newSheep = { isGolden: true, image: randomGoldenImage, speed: speed };
            } else {
                if (sheepQueue.length === 0) {
                     if (discardPile.length > 0) {
                         shuffleArray(discardPile);
                         sheepQueue = [...discardPile];
                         discardPile = [];
                     } else {
                         return; // No sheep left to draw at all
                     }
                }
                const nextSheepImage = sheepQueue.shift();
                
                speed = (Math.random() * 2 + 1) * levelSpeedMultiplier;
                newSheep = { isGolden: false, image: nextSheepImage, speed: speed };
            }
            
            const newSheepObject = {
                x: x, y: y, width: sheepWidth, height: sheepHeight,
                sx: 0, 
                hasBounced: false,
                isScared: false,
                scaredText: null,
                originalSpeed: speed,
                rotation: 0, 
                rotationSpeed: (Math.random() - 0.5) * 0.05,
                ...newSheep
            };

            if (newSheepObject.image === allImages.goldenBull) {
                newSheepObject.rotationSpeed = 0.015; // A gentle speed
                newSheepObject.rotationDirection = 1;
            }
            
            sheep.push(newSheepObject);
        }
        
        function endGame(won, reason = null) {
            isGameOver = true;
            playerWon = won;
            if (won) {
                 if (currentLevel < 8) {
                    gameOverMessage = `Level ${currentLevel} Complete!`;
                    totalSheepSaved += caughtSheep.length;
                } else {
                    gameOverMessage = 'You Win!';
                    totalSheepSaved += caughtSheep.length;
                }
            } else {
                loseReason = reason;
                totalSheepSaved += caughtSheep.length; // Add sheep from the losing round
            }
            sheep = [];
            clearInterval(sheepInterval);
            gameStarted = false;
        }

        function update() {
             // Handle pointer controls
            if (isPointerActive && pointerGameX !== null) {
                const playerCenter = player.x + player.width / 2;
                const distance = pointerGameX - playerCenter;

                if (Math.abs(distance) < player.speed) {
                    player.dx = 0; // Stop if close enough
                } else if (distance > 0) {
                    player.dx = player.speed;
                } else {
                    player.dx = -player.speed;
                }
            }

            player.x += player.dx;

            const rightBoundary = GAME_WIDTH - scoreSheepWidth - 10 - player.width;
            if (player.x < 0) player.x = 0;
            if (player.x > rightBoundary) player.x = rightBoundary;

            // Cow Movement
            if(currentLevel === 3 || currentLevel === 4 || currentLevel >= 7) {
                cow.x += cow.dx;
                if(cow.x + cow.width > rightBoundary || cow.x < 0){
                    cow.dx *= -1;
                }
            }
            // Scarecrow Movement
            if(currentLevel >= 5) {
                scarecrow.x += scarecrow.dx;
                if(scarecrow.x + scarecrow.width > rightBoundary || scarecrow.x < 0){
                    scarecrow.dx *= -1;
                }
            }

            for (let i = sheep.length - 1; i >= 0; i--) {
                const s = sheep[i];
                if (!s) continue;

                const playerHitbox = { x: player.x + player.width * 0.25, y: player.y, width: player.width * 0.5, height: player.height };

                if (s.isScared) {
                    if (s.scarePause > 0) {
                        s.scarePause--;
                    } else {
                         s.speed -= 0.2;
                         if (s.scaredText && s.scaredText.alpha > 0) {
                            s.scaredText.alpha -= 0.02;
                        }
                    }
                } else if (s.hasBounced) {
                    s.speed += 0.2; 
                }
                
                if (! (s.isScared && s.scarePause > 0)) {
                    s.y += s.speed;
                    s.x += s.sx;
                }
                
                if (s.isGolden && s.image === allImages.goldenBull) {
                    if (s.rotation > 0.5 || s.rotation < -0.5) {
                        s.rotationDirection *= -1;
                    }
                    s.rotation += s.rotationSpeed * s.rotationDirection;
                } else {
                    if(s.speed < 0) s.rotation -= s.rotationSpeed * 2;
                    else s.rotation += s.rotationSpeed;
                }

                if ((s.hasBounced && (s.x + s.width < 0 || s.x > rightBoundary)) || (s.isScared && s.y < -s.height)) {
                    discardPile.push(s.image); // Add to discard pile
                    sheep.splice(i, 1);
                    continue; 
                }

                // Scarecrow logic
                if(currentLevel >= 5 && !s.isGolden && !s.hasBounced && !s.isScared){
                    const scareZone = { x: scarecrow.x - 40, y: scarecrow.y - 40, width: scarecrow.width + 80, height: scarecrow.height + 80 };
                    if(s.x < scareZone.x + scareZone.width && s.x + s.width > scareZone.x && s.y < scareZone.y + scareZone.height && s.y + s.height > scareZone.y){
                        s.isScared = true;
                        s.speed = 0; // Pause
                        s.scarePause = 50; // Pause for 50 frames
                        s.scaredText = { text: scaredPhrases[Math.floor(Math.random() * scaredPhrases.length)], alpha: 1.0 };
                        setTimeout(() => {
                           if(s.isScared) {
                                s.speed = -8;
                                s.sx = s.x < scarecrow.x + scarecrow.width / 2 ? -2 : 2;
                           }
                        }, 800); // .8 seconds
                        booMessage.text = 'BOO!'; booMessage.alpha = 1.0; booMessage.x = scarecrow.x + scarecrow.width / 2; booMessage.y = scarecrow.y - 10;
                    }
                }

                // Cow logic
                if((currentLevel === 3 || currentLevel === 4 || currentLevel >= 7) && !s.isScared){
                    const umbrella = { x: cow.x + 20, y: cow.y + 10, width: cow.width - 40, height: 40 };
                    if(s.x < umbrella.x + umbrella.width && s.x + s.width > umbrella.x && s.y < umbrella.y + umbrella.height && s.y + s.height > umbrella.y){
                        if(s.speed >= 0){ 
                           s.speed = -6 - s.originalSpeed;
                           s.sx = (Math.random() - 0.5) * 4; 
                           s.y = umbrella.y - s.height;
                           s.hasBounced = true;
                           mooMessage.text = 'MOO!'; mooMessage.alpha = 1.0; mooMessage.x = cow.x + cow.width / 2; mooMessage.y = cow.y - 10;
                        }
                    }
                }

                if (playerHitbox.x < s.x + s.width && playerHitbox.x + playerHitbox.width > s.x && playerHitbox.y < s.y + s.height && playerHitbox.y + playerHitbox.height > s.y) {
                    if (s.isGolden) {
                        goldenHits++;
                        totalGoldenHits++;
                        owMessage.text = 'OW!'; owMessage.alpha = 1.0; owMessage.x = player.x + player.width / 2; owMessage.y = player.y - 10;
                        if (goldenHits >= 4) {
                            endGame(false, "You've been smooshed!");
                        } else {
                            player.height = originalPlayerState.height * (1 - goldenHits * 0.25);
                            player.speed = originalPlayerState.speed * (1 - goldenHits * 0.25);
                            player.y = originalPlayerState.y + (originalPlayerState.height - player.height);
                        }
                    } else {
                        caughtSheep.push(s);

                        goldenSheepChance += 0.05;
                        if (goldenSheepChance > 0.8) goldenSheepChance = 0.8;
                        
                        if(currentLevel < 8 && caughtSheep.length >= levelCatchGoal){
                            endGame(true);
                        } else if (currentLevel === 8 && caughtSheep.length >= levelCatchGoal) {
                            endGame(true, 'You Win!');
                        }
                    }
                    sheep.splice(i, 1);
                    continue;
                }

                if (s.y > GAME_HEIGHT) {
                    if (!s.isGolden) {
                        if (!s.isScared) { // Scared sheep don't count as a miss
                             missedCount++;
                             totalSheepLost++;
                             discardPile.push(s.image); // Add missed sheep to discard
                             if (missedGraves.length < 3) {
                                const graveWidth = 50;
                                const graveHeight = 60;
                                const newGrave = {
                                    image: graveImages[Math.floor(Math.random() * graveImages.length)],
                                    x: 10 + (missedGraves.length * (graveWidth + 5)),
                                    y: GAME_HEIGHT - graveHeight,
                                    width: graveWidth,
                                    height: graveHeight
                                };
                                missedGraves.push(newGrave);
                            }
                            if (missedCount >= 3) endGame(false, "You missed too many sheep!");
                        } else {
                            discardPile.push(s.image); // Add scared sheep to discard
                        }
                    }
                    sheep.splice(i, 1);
                    continue;
                }
            }

            if (owMessage.alpha > 0) owMessage.alpha -= 0.02;
            if (mooMessage.alpha > 0) mooMessage.alpha -= 0.02;
            if (booMessage.alpha > 0) booMessage.alpha -= 0.02;
        }

        function gameLoop() {
            // --- Scaling and Resizing ---
            // This is now handled by CSS, but we set the canvas resolution once.
            // This loop just draws to the fixed internal resolution.
            
            // --- Main Game Draw Cycle ---
            clear();
            drawGraves();
            drawScoreStack();
            if(currentLevel === 3 || currentLevel === 4 || currentLevel >= 7) drawCow();
            if(currentLevel >= 5) drawScarecrow();
            drawPlayer();
            drawOwMessage();
            drawMooMessage();
            drawBooMessage();
            
            if (gameStarted) {
                if (!isPaused) {
                    update();
                }
                drawFallingSheep();
                drawFleeingText();
                drawUI();
                if (isPaused) {
                    drawPauseScreen();
                }
            }
            
            if(isGameOver) {
                 ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                 ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                 drawGameOver();
            }

            requestAnimationFrame(gameLoop);
        }
        
        function startGame(level) {
            currentLevel = level;
            isGameOver = false;
            playerWon = false;
            missedCount = 0;
            missedGraves = [];
            sheep = [];
            caughtSheep = [];
            discardPile = [];
            player.x = GAME_WIDTH / 2 - 35;
            player.dx = 0;
            goldenHits = 0;
            gameOverMessage = '';
            loseReason = '';
            owMessage.alpha = 0;
            mooMessage.alpha = 0;
            booMessage.alpha = 0;
           
            if (level === 1) {
                totalSheepSaved = 0; // Reset total count only on a new game
                totalSheepLost = 0;
                totalGoldenHits = 0;
            }

            // --- NEW LEVEL DECK CREATION LOGIC ---
            const levelPool = [...sheepImages];
            const corePool = [...normalSheepImages];
            shuffleArray(corePool);

            const introSheep = [];
            // Pick 3 unique core sheep
            while(introSheep.length < 3 && corePool.length > 0) {
                const candidate = corePool.shift();
                const indexInLevelPool = levelPool.indexOf(candidate);
                if (indexInLevelPool > -1) {
                    introSheep.push(candidate);
                    levelPool.splice(indexInLevelPool, 1);
                }
            }
            
            const mainDeck = levelPool;
            shuffleArray(mainDeck); 
            sheepQueue = introSheep.concat(mainDeck);


            clearInterval(sheepInterval);

            // Level specific settings
            switch(level) {
                case 1: levelSpeedMultiplier = 1.0; sheepInterval = setInterval(createSheep, 2000); goldenSheepChance = 0.1; levelCatchGoal = 10; break;
                case 2: levelSpeedMultiplier = 1.25; sheepInterval = setInterval(createSheep, 1700); goldenSheepChance = 0.15; levelCatchGoal = 10; break;
                case 3: levelSpeedMultiplier = 1.25; sheepInterval = setInterval(createSheep, 1700); goldenSheepChance = 0.2; levelCatchGoal = 10; break;
                case 4: levelSpeedMultiplier = 1.5; sheepInterval = setInterval(createSheep, 1400); goldenSheepChance = 0.25; levelCatchGoal = 15; break;
                case 5: levelSpeedMultiplier = 1.5; sheepInterval = setInterval(createSheep, 1400); goldenSheepChance = 0.25; levelCatchGoal = 15; break;
                case 6: levelSpeedMultiplier = 1.75; sheepInterval = setInterval(createSheep, 1200); goldenSheepChance = 0.3; levelCatchGoal = 15; break;
                case 7: levelSpeedMultiplier = 1.75; sheepInterval = setInterval(createSheep, 1200); goldenSheepChance = 0.35; levelCatchGoal = 15; break;
                case 8: levelSpeedMultiplier = 2.0; sheepInterval = setInterval(createSheep, 1000); goldenSheepChance = 0.4; levelCatchGoal = 20; break;
            }

            scoreSheepHeight = Math.floor(GAME_HEIGHT / levelCatchGoal);
            scoreSheepWidth = scoreSheepHeight; 

            player.height = originalPlayerState.height;
            player.speed = originalPlayerState.speed;
            player.y = originalPlayerState.y;

            gameStarted = true;
            startButton.style.display = 'none';
            launchScreen.style.display = 'none';
            credits.style.display = 'block'; // Make sure credits are visible
        }


        function handleButtonClick() {
            if (isGameOver && playerWon && currentLevel < 8) {
                startGame(currentLevel + 1);
            } else {
                startGame(1);
            }
        }

        // --- Event Listeners ---
        function moveRight() { player.dx = player.speed; }
        function moveLeft() { player.dx = -player.speed; }
        function stopMoving() { player.dx = 0; }

        function keyDown(e) {
            // Handle button presses
            if ((e.key === ' ' || e.key === 'Spacebar') && startButton.style.display !== 'none') {
                e.preventDefault();
                handleButtonClick();
                return;
            }
             // Handle pause
            if ((e.key === 'p' || e.key === 'P') && gameStarted && !isGameOver) {
                isPaused = !isPaused;
            }
            if (isPaused || !gameStarted || isGameOver) return;

            // Handle movement
            isPointerActive = false; // Keyboard overrides pointer
            if (e.key === 'ArrowRight' || e.key === 'Right' || e.key === 'd' || e.key === 'D') moveRight();
            else if (e.key === 'ArrowLeft' || e.key === 'Left' || e.key === 'a' || e.key === 'A') moveLeft();
        }

        function keyUp(e) {
            if (e.key === 'ArrowRight' || e.key === 'Right' || e.key === 'd' || e.key === 'D' || e.key === 'ArrowLeft' || e.key === 'Left' || e.key === 'a' || e.key === 'A') {
                stopMoving();
            }
        }

        function handlePointerDown(e) {
            if (!gameStarted || isGameOver) return;
            e.preventDefault();
            isPointerActive = true;
            const rect = canvas.getBoundingClientRect();
            const scale = rect.width / GAME_WIDTH;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            pointerGameX = (clientX - rect.left) / scale;
        }

        function handlePointerMove(e) {
            if (!isPointerActive) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scale = rect.width / GAME_WIDTH;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            pointerGameX = (clientX - rect.left) / scale;
        }

        function handlePointerUp(e) {
            e.preventDefault();
            isPointerActive = false;
            stopMoving();
        }

        document.addEventListener('keydown', keyDown);
        document.addEventListener('keyup', keyUp);
        
        // Mouse and Touch events
        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('mouseup', handlePointerUp);
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('touchstart', handlePointerDown, { passive: false });
        canvas.addEventListener('touchend', handlePointerUp, { passive: false });
        canvas.addEventListener('touchmove', handlePointerMove, { passive: false });
        
        startButton.addEventListener('click', handleButtonClick);

    </script>
</body>
</html>


